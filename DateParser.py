import datetime
import re
from spellchecker import SpellChecker

class DateParser:
    """
    A class to represent a DateParser.

    ...

    Attributes
    ----------
    base_date : str
        a string in YYYY-MM-DD format that is converted into a datetime to be used
        as a base date for the class
    input_string : str
        the string to be processed, cleaned, and broken out into tokens
    spell : SpellChecker
        the SpellChecker object if initialized
    tokens : list
        the list of tokens post initial processing

    Methods
    -------
    clean_string(input_string):
        Cleans the input string passed to it and returns the processed string
    get_tokens(input_string):
        Breaks the input string into tokens of alphabetical chunks and numeric chunks and
        returns them as a list
    extract_date()
        Uses the tokens generated by get_tokens to return a datetime representing
        the tokens descriptions
    """

    years = {
        "year" : 0,
        "in": 0,
    }

    year_mods = {
        "next": 1,
        "this": 0,
        "last": -1
    }

    months = {
        'january': 1,
        'jan': 1,
        'february': 2,
        'feb': 2,
        'march': 3,
        'mar': 3,
        'april': 4,
        'apr': 4,
        'may': 5,
        'june': 6,
        'jun': 6,
        'july': 7,
        'jul': 7,
        'august': 8,
        'aug': 8,
        'september': 9,
        'sep': 9,
        'october': 10,
        'oct': 10,
        'november': 11,
        'nov': 11,
        'december': 12,
        'dec': 12
    }

    month_pre_mods = {
        'next': 1,
        'last': -1
    }

    # Modifications that shift the day by a week, IE next Tuesday is the next Tuesday + a week
    day_week_pre_mods = {
        "next": 7,
        "last": -7,
        "coming": 0,
        "after": {
            "next": 7
        },
    }

    day_week_post_mods = {
        "after": {
            "next": 14,
            "this": 7
        },
        "of": {
            "next":7
        }
    }

    days = {
        "monday": 0,
        "tuesday":1,
        "wednesday":2,
        "thursday":3,
        "friday":4,
        "saturday":5,
        "sunday":6,
        "mon":0,
        "tues":1,
        "wed":2,
        "thurs":3,
        "fri": 4,
        "sat": 5,
        "sun": 6
    }

    day_relative = {
        "today": 0,
        "tomorrow": 1,
        "yesterday": -1,
    }

    # Modifications that only shift the date by a day, IE the day after monday is just Tuesday
    day_day_mods = {
        "after": 1,
        "before": -1,
    }

    hour = {
        "noon": 12,
        "midnight": 0,
    }

    hour_indicator = {
        "am": 0,
        "pm": 12
    }

    hour_pre_indicator = {
        "oclock": 0
    }

    minutes = {
        "halfpast": 30,
        "half": {
            "past": 30
        },
        "quarter": {
            "till": 45,
            "before": 45,
            "after": 15,
            "past": 15
        }
    }

    value_keyword = [
        "minutes", "days", "weeks", "months", "hours", "years"
    ]

    value_modifier = {
        "from":
            [
                "now",
                "yesterday",
                "tomorrow"
            ],
        "ago": -1,
        "before": -1
    }

    # Better to use a library and have a conversion system for any incoming numbers in english.
    # Only using this in the pm/am logic for now, expansion would be during input cleanup
    # converting any english written numbers to their proper numbers as a preprocessing step
    engNums = {
        "zero": 0,
        "one": 1,
        "two": 2,
        "three": 3,
        "four": 4,
        "five": 5,
        "six": 6,
        "seven": 7,
        "eight": 8,
        "nine": 9,
        "ten": 10,
        "eleven": 11,
        "twelve": 12,
        "thirteen": 13,
        "fourteen": 14,
        "fifteen": 15,
        "sixteen": 16,
        "seventeen": 17,
        "eighteen": 18,
        "nineteen": 19,
        "twenty": 20,
        "thirty": 30
    }

    def __init__(self, input_string, base_date=None, spellcheck=False) -> None:
        self.pre_mod_input = input_string
        self.input_string = self.clean_string(input_string)
        self.spell = None
        if spellcheck:
            self.spell = SpellChecker(distance=2)
            self.spell.word_frequency.load_text_file("datewords.txt")
        self.tokens = self.get_tokens(self.input_string)
        if base_date:
            try:
                self.base_date = datetime.datetime.fromisoformat(base_date)
            except ValueError:
                raise ValueError("Incorrect data format, should be YYYY-MM-DD")
        else:
            self.base_date = datetime.datetime.today()

    @staticmethod
    def clean_string(input_string):
        """
        Cleans up the input string by applying lower(), strip() and removing filler words
        Args:
            string input_string: the unprocessed input string

        Returns:
            string clean_string: The processed string

        """
        # Cleanup any nonalphanumeric and non space characters + any trailing or leading whitespace
        clean_string = re.sub(r'[^A-Za-z0-9 ]+', '', input_string).lower().strip()
        # Remove "the", "a", "an", "of" as they do not impact the date
        clean_string = clean_string.replace(" the ", " ").replace(" a "," ") \
        .replace(" an "," ").replace(" of "," ")
        # remove st, rd, th and nd from numbers
        clean_string = re.sub(r'(\d+)(st |rd |th |nd )', r'\1 ', clean_string)

        return clean_string


    def get_tokens(self, input_string):
        """
        Splits out the input string into tokens that are purely alphabetical or numeric.
        Also spellchecks if True was passed to the spellcheck at initialization
        Args:
            text input_string:

        Returns:
            list
            The original string split into tokens

        """
        tokens = re.findall(r"[^\W\d_]+|\d+", input_string)

        if self.spell:
            misspelled = self.spell.unknown(tokens)
            for word in misspelled:
                index = tokens.index(word)
                tokens[index] = self.spell.correction(word)

        if not tokens:
            print("No data to parse")
        return tokens

    def extract_date(self):
        """
        Parses the processed tokens into a datetime
        Args:
            None

        Returns:
            datetime
            The parsed datetime from the string the class was initialized with

        """
        day = None
        day_modifier = 0
        month = None
        month_modifier = 0
        year = None
        year_modifier = 0
        hour = None
        hour_modifier = 0
        minute = None
        minute_modifier = 0
        token_len = len(self.tokens)
        orig_day_val = self.base_date.weekday()
        orig_month_val = self.base_date.month

        for index, token in enumerate(self.tokens):

            # Set tokens to empty if used to avoid a scenario where 'march after next year'
            # could be doubly interpreted into 'march after next' and 'next year'.
            # Skip those tokens once set as empty
            if token == '':
                continue

            # For context grab the two tokens before and after our current token,
            # as we can expect values, modifiers, etc.
            two_words_before = None
            word_before = None
            word_after = None
            two_words_after = None
            if index != 0:
                word_before = self.tokens[index-1]
            if index != token_len-1:
                word_after = self.tokens[index+1]
            if index > 1:
                two_words_before = self.tokens[index-2]
            if index < token_len-2:
                two_words_after = self.tokens[index+2]

            # if we see a plural form of a unit of time, we want to see
            # what value is before it and what keywords are after it
            if token in self.value_keyword:
                modifier = 0
                if re.match(r'\d+', word_before):
                    modifier = int(word_before)
                    self.tokens[index-1] = ''
                if word_after in self.value_modifier:
                    if word_after != 'from':
                        modifier = modifier * -1
                        self.tokens[index+1] = ''
                if token == 'years':
                    year_modifier += modifier
                elif token == 'months':
                    month_modifier += modifier
                elif token == 'weeks':
                    day_modifier += modifier*7
                elif token == 'days':
                    day_modifier += modifier
                elif token == 'hours':
                    hour_modifier += modifier
                elif token == 'minutes':
                    minute_modifier += modifier
                self.tokens[index] = ''

            # Logic for if we see a day of the week
            if token in self.days:
                day_val = self.days.get(token)
                self.tokens[index] = ''
                if orig_day_val < day_val:
                    day_modifier += day_val - orig_day_val
                elif day_val < orig_day_val:
                    day_modifier += day_val + 7 - orig_day_val
                if self.day_week_pre_mods.get(word_before):
                    day_modifier += self.day_week_pre_mods.get(word_before)
                    self.tokens[index-1] = ''
                elif self.day_week_post_mods.get(word_after):
                    if self.day_week_post_mods[word_after].get(two_words_after):
                        day_modifier += self.day_week_post_mods[word_after].get(two_words_after)
                        self.tokens[index+1] = ''
                        self.tokens[index+2] = ''

            # logic for if we see year or in
            if token in self.years:
                if word_before in self.year_mods:
                    year_modifier += self.year_mods.get(word_before)
                    self.tokens[index-1] = ''
                elif re.match(r'\d{4}', word_after):
                    year = int(word_after)
                    self.tokens[index+1] = ''
                self.tokens[index] = ''

            # Logic for if we see today/tomorrow/yesterday
            if token in self.day_relative:
                day_modifier += self.day_relative.get(token)
                self.tokens[index] = ''

            # Logic for if we see the name of the month
            if token in self.months:
                month_val = self.months.get(token)
                self.tokens[index] = ''
                if orig_month_val < month_val:
                    month_modifier += month_val - orig_month_val
                elif month_val < orig_month_val:
                    month_modifier += month_val + 12 - orig_month_val
                if word_before:
                    if self.month_pre_mods.get(word_before):
                        year_modifier += self.month_pre_mods.get(word_before)
                        self.tokens[index-1] = ''
                    elif re.match(r'\d{1,2}', word_before):
                        day = int(re.match(r'\d{1,2}', word_before))
                        self.tokens[index-1] = ''
                if word_after and re.match(r'\d{4}', word_after):
                    year = int(word_after)
                    self.tokens[index+1] = ''
                elif word_after and re.match(r'\d{2}', word_after):
                    day = int(word_after)
                    self.tokens[index+1] = ''
                    if word_after and re.match(r'\d{4}', two_words_after):
                        year = int(two_words_after)
                        self.tokens[index+2] = ''

            # Logic for phrases indicating minutes
            if token in self.minutes:
                if isinstance(self.minutes.get(token), int):
                    minute = self.minutes.get(token)
                    self.tokens[index] = ''
                elif self.minutes[token].get(word_before):
                    minute = self.minutes[token].get(word_before)
                    self.tokens[index] = ''
                    self.tokens[index-1] = ''

            # Logic for if we see noon/midnight (can be expanded to dawn/dusk/morning/afternoon etc)
            if token in self.hour:
                hour = self.hour.get(token)
                # Weird condition, do we mean midnight tonight? that is technically 00:00 tomorrow?
                # Assuming instead that we mean midnight of what we consider tomorrow night
                # which is 00:00 two days from now
                if token == 'midnight':
                    day_modifier += 1
                self.tokens[index] = ''

            # Logic once we see AM or PM indicating an hour and possibly minutes
            if token in self.hour_indicator:
                hour_modifier = self.hour_indicator.get(token)
                self.tokens[index] = ''
                if word_before in self.hour_pre_indicator:
                    if re.match(r'\d{1,2}', two_words_before):
                        hour = int(two_words_before)
                        self.tokens[index-1] = ''
                        self.tokens[index-2] = ''
                elif re.match(r'\d{1,2}', word_before) is None:
                    if self.engNums.get(token):
                        hour = self.engNums.get(token)
                        self.tokens[index-1] = ''
                    else:
                        raise ValueError("invalid hour found")
                else:
                    # 3-4 digit number before am/pm should be interpretted as HHMM
                    if word_before and re.match(r'\d{3,4}', word_before):
                        split = len(word_before)//2
                        hour = int(word_before[0:split])
                        minute = int(word_before[split:4])
                        self.tokens[index-1] = ''
                    elif word_before and two_words_before and re.match(r'\d{1,2}', word_before) \
                    and re.match(r'\d{1,2}', two_words_before):
                        hour = int(two_words_before)
                        minute = int(word_before)
                        self.tokens[index-1] = ''
                        self.tokens[index-2] = ''
                    elif word_before and re.match(r'\d{1,2}', word_before):
                        hour = int(word_before)
                        self.tokens[index-1] = ''
                    # If someone asks for 23 PM just assume they want hour 23. Also handle 12 pm
                    if hour >= 12 and hour < 24 and token == 'pm':
                        hour_modifier -= 12
                    elif hour > 24 or hour < 0:
                        raise ValueError("invalid hour found")

        if year is None:
            year = self.base_date.year
        if month is None:
            month = self.base_date.month
        if day is None:
            day = self.base_date.day
        if hour and not minute:
            minute = 0
        if not hour and not minute:
            hour = self.base_date.hour
            minute = self.base_date.minute

        return_date = datetime.datetime(year, month, day, hour, minute)

        if year_modifier:
            try:
                return return_date.replace(year = return_date.year + year_modifier)
            except ValueError:
                return return_date + (datetime.datetime(return_date.year + year_modifier, 1, 1)
                                      - datetime.datetime(return_date.year, 1, 1))
        if month_modifier:
            return_date = return_date + datetime.timedelta(months=month_modifier)
        if day_modifier:
            return_date = return_date + datetime.timedelta(days=day_modifier)
        if hour_modifier:
            return_date = return_date + datetime.timedelta(hours=hour_modifier)
        if minute_modifier:
            return_date = return_date + datetime.timedelta(minutes=minute_modifier)

        # print(f'Input was: {self.pre_mod_input}, output is :{return_date}')
        return return_date
